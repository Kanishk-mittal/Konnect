# API Encryption Documentation

## Overview

This document describes the encryption format used for secure communication between the frontend and backend in the Konnect application. The system uses hybrid encryption (RSA + AES) to ensure secure data transmission.

## Encryption System

### Hybrid Encryption Approach
- **AES-256-GCM**: Used for encrypting the actual payload data (fast, symmetric)
- **RSA-OAEP**: Used for encrypting the AES key (secure, asymmetric)
- **Key Management**: Server maintains RSA key pairs with rotation support

## Request Encryption Format

### All Encrypted Requests Must Follow This Structure:

```json
{
  "key": "base64-encoded-encrypted-AES-key",
  "keyId": "server-key-identifier", 
  "data": "base64-encoded-encrypted-payload",
  "publicKey": "client-public-key-pem-format" // Optional, for response encryption
}
```

### Field Descriptions:

- **`key`**: The AES key (generated by client) encrypted with server's RSA public key
- **`keyId`**: Identifier of the server's RSA key used for encryption (obtained from `/encryption/rsa/publicKey`)
- **`data`**: The actual request payload (JSON) encrypted with the AES key
- **`publicKey`**: Client's RSA public key (optional) - used by server to encrypt response back to client

### Encryption Process (Client-Side):

1. **Get Server's Public Key**: Call `GET /encryption/rsa/publicKey` to get server's public key and keyId
2. **Generate AES Key**: Create a random 256-bit AES key
3. **Encrypt Payload**: Encrypt your JSON payload using AES-256-GCM
4. **Encrypt AES Key**: Encrypt the AES key using server's RSA public key
5. **Send Request**: Send the structured request with encrypted data

## Response Encryption Format

### Encrypted Responses Follow This Structure:

```json
{
  "data": "base64-encoded-encrypted-response",
  "key": "base64-encoded-encrypted-AES-key"
}
```

### Field Descriptions:

- **`data`**: The actual response (JSON) encrypted with AES-256-GCM
- **`key`**: The AES key encrypted with client's RSA public key

### Decryption Process (Client-Side):

1. **Decrypt AES Key**: Use your RSA private key to decrypt the `key` field
2. **Decrypt Response**: Use the decrypted AES key to decrypt the `data` field
3. **Parse JSON**: Parse the decrypted string as JSON

## Encrypted Endpoints

### Admin Endpoints

#### `POST /admin/register`

**Request Payload** (before encryption):
```json
{
  "collegeName": "University Name",
  "adminUsername": "admin_username",
  "collegeCode": "COLLEGE123",
  "emailId": "admin@college.edu",
  "password": "secure_password",
  "otp": "123456"
}
```

**Response Payload** (after decryption):
```json
{
  "status": true,
  "message": "Registration successful! Welcome to Konnect.",
  "data": {
    "recoveryKey": "recovery-key-for-account-recovery",
    "privateKey": "user-rsa-private-key-pem",
    "id": "user-database-id"
  }
}
```

#### `POST /admin/login`

**Request Payload** (before encryption):
```json
{
  "collegeCode": "COLLEGE123",
  "username": "admin_username", 
  "password": "user_password"
}
```

**Response Payload** (after decryption):
```json
{
  "status": true,
  "message": "Login successful!",
  "data": {
    "id": "user-database-id",
    "privateKey": "user-rsa-private-key-pem"
  }
}
```

## Implementation Examples

### Frontend Example (JavaScript)

```javascript
// 1. Get server's public key
const serverKeyResponse = await fetch('/encryption/rsa/publicKey');
const { publicKey: serverPublicKey, keyId } = await serverKeyResponse.json();

// 2. Generate client RSA key pair (for response encryption)
const clientKeyPair = generateRSAKeyPair();

// 3. Prepare your payload
const payload = {
  collegeCode: "COLLEGE123",
  username: "admin_user",
  password: "secure_password"
};

// 4. Generate AES key and encrypt payload
const aesKey = generateAESKey();
const encryptedPayload = encryptAES(JSON.stringify(payload), aesKey);

// 5. Encrypt AES key with server's public key
const encryptedAESKey = encryptRSA(aesKey, serverPublicKey);

// 6. Send encrypted request
const response = await fetch('/admin/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    key: encryptedAESKey,
    keyId: keyId,
    data: encryptedPayload,
    publicKey: clientKeyPair.publicKey // For response encryption
  })
});

// 7. Decrypt response
const encryptedResponse = await response.json();
if (encryptedResponse.data && encryptedResponse.key) {
  // Decrypt AES key with client's private key
  const responseAESKey = decryptRSA(encryptedResponse.key, clientKeyPair.privateKey);
  
  // Decrypt response data
  const decryptedResponse = decryptAES(encryptedResponse.data, responseAESKey);
  const responseData = JSON.parse(decryptedResponse);
  
  console.log('Login response:', responseData);
}
```

## Security Features

### Request Security
- ✅ **End-to-End Encryption**: All sensitive data encrypted from client to server
- ✅ **Key Rotation**: Server keys can be rotated without breaking existing sessions
- ✅ **Perfect Forward Secrecy**: Each request uses a new AES key
- ✅ **Tamper Detection**: AES-GCM provides authentication

### Response Security  
- ✅ **Authenticated Users**: Uses stored public key from database
- ✅ **Unauthenticated Users**: Uses public key provided in request
- ✅ **Selective Encryption**: Only sensitive endpoints use response encryption
- ✅ **Graceful Fallback**: Unencrypted responses if encryption fails

## Error Handling

### Common Error Responses

```json
{
  "status": false,
  "message": "Failed to decrypt request data. Please check your request format."
}
```

```json
{
  "status": false,
  "message": "Invalid key identifier. Key may have expired."
}
```

### Debugging Tips

1. **Check Key ID**: Ensure you're using the latest keyId from `/encryption/rsa/publicKey`
2. **Verify Format**: Ensure request follows exact JSON structure
3. **Check Encryption**: Verify AES and RSA encryption implementations
4. **Monitor Logs**: Server logs will show encryption success/failure

## Migration from Manual Encryption

If you're migrating from manual encryption:

1. **No Request Changes**: Request format remains identical
2. **Response Changes**: Responses now automatically encrypted by middleware
3. **Controller Simplification**: Controllers no longer need manual encryption code
4. **Backward Compatibility**: Old and new systems can coexist during migration

---

**Last Updated**: September 19, 2025  
**Version**: 2.0 (Middleware-based encryption)