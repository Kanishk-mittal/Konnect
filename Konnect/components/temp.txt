const csrfToken = document.cookie
      .split('; ')
      .find(row => row.startsWith('csrf_access_token='))
      ?.split('=')[1];
    
    if (!csrfToken) {
      return [];
    }
    
    try {
      const response = await instance.post('/get_group_keys', {
        group_id: groupId
      }, {
        headers: { "X-CSRF-TOKEN": csrfToken }
      });
      
      return response.data.keys || [];
    } catch (error) {
      setError("Failed to get group keys");
      return [];
    }








// Handle received messages from socket
  const handleReceivedMessage = (data) => {
    try {
        // Decrypt sender
        const sender = decryptWithAES(data.sender, serverKey);
        
        // Decrypt receiver
        const receiver = decryptWithAES(data.receiver, serverKey);
        
        // Check if group message
        let group = null;
        if (data.group) {
            group = decryptWithAES(data.group, serverKey);
        }
        
        // Decrypt the AES key using private RSA key
        const decryptedAESKey = decryptRSAKey(data.key, privateKey);
        if (!decryptedAESKey) {
            return;
        }
        
        // Decrypt the message
        const decryptedMessage = decryptWithAES(data.message, decryptedAESKey);
        
        // Check if this message belongs to the currently active chat
        let belongsToCurrentChat = false;
        if (chatType === 'user') {
            // For direct messages:
            const isFromSelectedChatToMe = selectedChat === sender && roll.current === receiver;
            const isNotGroupMessage = group === null;
            belongsToCurrentChat = isFromSelectedChatToMe && isNotGroupMessage;
        } else if (chatType === 'group') {
            // For group messages, just check if the group ID matches
            belongsToCurrentChat = selectedChat === group;
        }
        
        // Generate message ID - for group messages, use consistent ID based on group+sender+timestamp
        const messageId = group ? 
            CryptoJS.SHA256(sender + group + data.timestamp).toString() :
            CryptoJS.SHA256(sender + receiver + data.timestamp).toString();
        
        // Create message object
        const newMessage = {
            id: messageId,
            text: decryptedMessage,
            sender: sender,
            receiver: receiver,
            timestamp: data.timestamp,
            group: group,
            is_seen: sender === roll.current || belongsToCurrentChat // Rule 1 or 2.1
        };
        
        // When message doesn't belong to current chat, trigger notification
        if (!belongsToCurrentChat && sender !== roll.current) {
          // Dispatch notification event for new message
          window.dispatchEvent(new CustomEvent('newMessage', {
            detail: {
              sender: sender,
              chatId: group || sender,
              type: group ? 'group' : 'user',
              message: decryptedMessage.substring(0, 30) + (decryptedMessage.length > 30 ? '...' : '')
            }
          }));
          console.log(`Notification event dispatched for ${group ? 'group' : 'user'} message`);
        }
        
        // Check if this message already exists in database (for group messages)
        // to avoid duplicate messages
        if (group) {
            const transaction = dbRef.current.transaction(['messages'], 'readonly');
            const store = transaction.objectStore('messages');
            const request = store.get(messageId);
            
            request.onsuccess = (event) => {
                const existingMessage = event.target.result;
                if (existingMessage) {
                    // Message already exists, no need to save it again
                    return;
                }
                // Message doesn't exist, save it
                saveAndDisplayMessage(newMessage, belongsToCurrentChat);
            };
            
            request.onerror = () => {
                // On error, try to save anyway
                saveAndDisplayMessage(newMessage, belongsToCurrentChat);
            };
        } else {
            // For direct messages, just save and display
            saveAndDisplayMessage(newMessage, belongsToCurrentChat);
        }
    } catch (error) {
        console.error("Message processing error:", error);
        setError("Failed to process message: " + (error.message || error));
    }
  };




  // Helper function to save and display a message
  const saveAndDisplayMessage = (message, belongsToCurrentChat) => {
    saveMessageToDB(message)
        .then(() => {
            if (belongsToCurrentChat) {
                // Update UI with new message
                setMessages(prevMessages => [
                    ...prevMessages, 
                    {
                        ...message,
                        sender: message.sender === roll.current ? "user" : "friend"
                    }
                ]);
                // Scroll to bottom
                if (messagesContainerRef.current) {
                    messagesContainerRef.current.scrollTop = messagesContainerRef.current.scrollHeight;
                }
            }
        })
        .catch(error => {
            console.error("Database save error:", error);
            setError("Failed to save message: " + (error.message || error));
        });
  };



  // Fetch stored messages from server
  const fetchStoredMessages = async () => {
    try {
        const response = await instance.get('/get_messages');
        // This call also marks the user as online
        if (response.data.messages && response.data.messages.length > 0) {
            // Process each message as needed
        }
    } catch (err) {
        // Silently fail - we'll still have messages from IndexedDB
    }
  };



  const setUserOffline = () => {
  if (!currentUser) return;

  // Use a unique ID to deduplicate requests
  const requestId = `offline_${roll.current}_${Date.now()}`;
  
  // Don't send if we've already sent a request in the last 3 seconds
  if (window.lastOfflineRequest && 
      Date.now() - window.lastOfflineRequest < 3000) {
    console.log("Skipping duplicate offline request");
    return;
  }
  
  window.lastOfflineRequest = Date.now();

  // Prepare data for the request
  const data = {
    roll_number: roll.current,
    timestamp: new Date().toISOString(),
    request_id: requestId
  };

  try {
    // For normal navigation, fetch is more reliable than sendBeacon
    fetch(`${API_BASE_URL}/set_offline`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify(data)
    }).catch(err => console.error("Fetch error:", err));
    
    console.log("User set to offline");
  } catch (error) {
    console.error("Failed to set user offline:", error);
  }
};